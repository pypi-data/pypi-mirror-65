@dc.dataclass
class RsyncProtocol(SyncProtocol):

    @classmethod
    def validate_sync_spec(cls,
                           sync_spec: SyncSpec,
    ):
        """Validate that the sync_spec is supported by this protocol."""

        raise NotImplementedError

        pass

    @classmethod
    def _compile_rsync_options(cls,
                               sync_spec: SyncSpec,
    ):
        """Given the high level specification of intended behavior compile the
        appropriate options for rsync."""


        # TODO: read spec

        info_options = rsync.InfoOptions(
            flags=(),
        )

        options = rsync.Options(
            flags=(),
            includes=(),
            excludes=(),
            info=info_options,
        )

        return options



    @classmethod
    def gen_sync_func(cls,
                      local_cx: Context,
                      image: Image,
                      src: Replica,
                      target: Replica,
                      sync_spec: SyncSpec,
    ) -> Callable[[Context], None]:

        ## Validate

        # validate the sync spec for this protocol
        if not cls.validate_sync_spec(sync_spec):
            raise ValueError(f"Invalid SyncSpec for this protocol: {self.__name__}")

        ## Compile Sync Spec to Options


        ## Generate enpoint URLs

        # get the conn specs which have the needed info
        src_conn = image.network.resolve_peer_connection(src.peer)
        target_conn = image.network.resolve_peer_connection(target.peer)

        # TODO: construct the URL parts for using in rsync: user,
        # host, and path

        if src_conn is None:
            pass
        else:
            src_endpoint = rsync.Endpoint(
                src_replica_path,
                src_conn['user'],
                src_conn['host']
            )

        if target_conn is None:
            pass
        else:
            target_endpoint = rsync.Endpoint(
                target_replica_path,
                target_conn['user'],
                target_conn['host']
            )

        # get contexts (either Context or fabric Connection objects)
        # for each replica

        target_cx, target_replica_path = self.resolve_replica(local_cx, target_replica)

        print(src_replica_path)
        print(target_replica_path)

        # user and hostnames come the network config and so must be
        # resolved from the peer name


        # the path to the actual resource tree is a combination of the
        # anchor (where a peer is mounted) and the replica prefix (the
        # path to a replica subtree relative to the root of a peer)

        # convert the replicas to a URL
        src_url = image.resolve_url(local_cx, src)
        target_url = image.resolve_url(local_cx, src)

        # the command will be evaluated from the src replica so get
        # the context to it which is potentially remote via
        # fabric.Connection
        src_cx = network.resolve_replica(local_cx, src_replica)

        # generate the rsync command
        command = rsync.Command(
            src=src_endpoint,
            dest=target_endpoint,
            options=options,
        )

        ## Generate the execution function

        # TODO: remove not needed
        # get the source context on which we can execute the synchronization command
        # src_cx, src_replica_path = image.network.resolve_peer_context(local_cx, src.peer)

        # render the command
        command_str = command.render()

        # return this closure which is the callable that actually
        # executes the sync process
        def _sync_func(src_cx):
            src_cx.run(command_str)

        return _sync_func
