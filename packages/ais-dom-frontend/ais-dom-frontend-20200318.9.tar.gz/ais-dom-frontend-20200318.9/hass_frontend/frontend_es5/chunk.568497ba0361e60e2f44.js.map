{"version":3,"sources":["webpack:///./src/common/util/time-cache-function-promise.ts","webpack:///./src/data/camera.ts","webpack:///./src/panels/lovelace/components/hui-image.ts","webpack:///./src/common/util/parse-aspect-ratio.ts","webpack:///./src/data/auth.ts"],"names":["timeCachePromiseFunc","_ref","regeneratorRuntime","mark","_callee","cacheKey","cacheTime","func","hass","entityId","_len","args","_key","cache","lastResult","result","_args","arguments","wrap","_context","prev","next","length","Array","abrupt","apply","concat","then","setTimeout","undefined","stop","_x","_x2","_x3","_x4","_x5","this","CAMERA_SUPPORT_STREAM","computeMJPEGStreamUrl","entity","entity_id","attributes","access_token","fetchThumbnailUrlWithCache","fetchThumbnailUrl","camera_asyncToGenerator","path","getSignedPath","sent","hassUrl","fetchStreamUrl","_ref2","_callee2","format","data","stream","_context2","type","callWS","url","fetchCameraPrefs","updateCameraPrefs","prefs","Object","assign","_decorate","customElement","_initialize","_LitElement","HuiImage","_LitElement2","_getPrototypeOf2","_this","_classCallCheck","_getPrototypeOf","call","_assertThisInitialized","_inherits","F","d","kind","decorators","property","key","value","query","_get","prototype","_attached","cameraImage","cameraView","_startUpdateCameraInterval","_stopUpdateCameraInterval","imageSrc","cameraObj","ratio","aspectRatio","parseAspectRatio","stateObj","states","state","imageFallback","stateImage","_cameraImageSrc","image","filter","stateFilter","STATES_OFF","includes","html","_templateObject","styleMap","paddingBottom","w","h","toFixed","classMap","Boolean","_templateObject2","_templateObject3","_onImageError","_onImageLoad","display","_loadError","height","_lastImageHeight","changedProps","has","_updateCameraImageSrc","_this2","_cameraUpdater","window","setInterval","clearInterval","_onImageLoad2","_asyncToGenerator","updateComplete","_image","offsetHeight","_updateCameraImageSrc2","static","css","_templateObject4","LitElement","__webpack_require__","__webpack_exports__","parseOrThrow","num","parsed","parseFloat","isNaN","Error","input","endsWith","substr","arr","replace","split","err","fetchAuthProviders","location","protocol","host","fetch","credentials"],"mappings":"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","file":"chunk.568497ba0361e60e2f44.js","sourcesContent":["import { HomeAssistant } from \"../../types\";\n\ninterface ResultCache<T> {\n  [entityId: string]: Promise<T> | undefined;\n}\n\nexport const timeCachePromiseFunc = async <T>(\n  cacheKey: string,\n  cacheTime: number,\n  func: (\n    hass: HomeAssistant,\n    entityId: string,\n    ...args: unknown[]\n  ) => Promise<T>,\n  hass: HomeAssistant,\n  entityId: string,\n  ...args: unknown[]\n): Promise<T> => {\n  let cache: ResultCache<T> | undefined = (hass as any)[cacheKey];\n\n  if (!cache) {\n    cache = hass[cacheKey] = {};\n  }\n\n  const lastResult = cache[entityId];\n\n  if (lastResult) {\n    return lastResult;\n  }\n\n  const result = func(hass, entityId, ...args);\n  cache[entityId] = result;\n\n  result.then(\n    // When successful, set timer to clear cache\n    () =>\n      setTimeout(() => {\n        cache![entityId] = undefined;\n      }, cacheTime),\n    // On failure, clear cache right away\n    () => {\n      cache![entityId] = undefined;\n    }\n  );\n\n  return result;\n};\n","import { HomeAssistant, CameraEntity } from \"../types\";\nimport { timeCachePromiseFunc } from \"../common/util/time-cache-function-promise\";\nimport { getSignedPath } from \"./auth\";\n\nexport const CAMERA_SUPPORT_ON_OFF = 1;\nexport const CAMERA_SUPPORT_STREAM = 2;\n\nexport interface CameraPreferences {\n  preload_stream: boolean;\n}\n\nexport interface CameraThumbnail {\n  content_type: string;\n  content: string;\n}\n\nexport interface Stream {\n  url: string;\n}\n\nexport const computeMJPEGStreamUrl = (entity: CameraEntity) =>\n  `/api/camera_proxy_stream/${entity.entity_id}?token=${entity.attributes.access_token}`;\n\nexport const fetchThumbnailUrlWithCache = (\n  hass: HomeAssistant,\n  entityId: string\n) =>\n  timeCachePromiseFunc(\n    \"_cameraTmbUrl\",\n    9000,\n    fetchThumbnailUrl,\n    hass,\n    entityId\n  );\n\nexport const fetchThumbnailUrl = async (\n  hass: HomeAssistant,\n  entityId: string\n) => {\n  const path = await getSignedPath(hass, `/api/camera_proxy/${entityId}`);\n  return hass.hassUrl(path.path);\n};\n\nexport const fetchStreamUrl = async (\n  hass: HomeAssistant,\n  entityId: string,\n  format?: \"hls\"\n) => {\n  const data = {\n    type: \"camera/stream\",\n    entity_id: entityId,\n  };\n  if (format) {\n    // @ts-ignore\n    data.format = format;\n  }\n  const stream = await hass.callWS<Stream>(data);\n  stream.url = hass.hassUrl(stream.url);\n  return stream;\n};\n\nexport const fetchCameraPrefs = (hass: HomeAssistant, entityId: string) =>\n  hass.callWS<CameraPreferences>({\n    type: \"camera/get_prefs\",\n    entity_id: entityId,\n  });\n\nexport const updateCameraPrefs = (\n  hass: HomeAssistant,\n  entityId: string,\n  prefs: {\n    preload_stream?: boolean;\n  }\n) =>\n  hass.callWS<CameraPreferences>({\n    type: \"camera/update_prefs\",\n    entity_id: entityId,\n    ...prefs,\n  });\n","import { STATES_OFF } from \"../../../common/const\";\n\nimport parseAspectRatio from \"../../../common/util/parse-aspect-ratio\";\nimport {\n  LitElement,\n  TemplateResult,\n  html,\n  property,\n  CSSResult,\n  css,\n  PropertyValues,\n  query,\n  customElement,\n} from \"lit-element\";\nimport { HomeAssistant, CameraEntity } from \"../../../types\";\nimport { styleMap } from \"lit-html/directives/style-map\";\nimport { classMap } from \"lit-html/directives/class-map\";\nimport { fetchThumbnailUrlWithCache } from \"../../../data/camera\";\n\nconst UPDATE_INTERVAL = 10000;\nconst DEFAULT_FILTER = \"grayscale(100%)\";\n\nexport interface StateSpecificConfig {\n  [state: string]: string;\n}\n\n@customElement(\"hui-image\")\nexport class HuiImage extends LitElement {\n  @property() public hass?: HomeAssistant;\n\n  @property() public entity?: string;\n\n  @property() public image?: string;\n\n  @property() public stateImage?: StateSpecificConfig;\n\n  @property() public cameraImage?: string;\n\n  @property() public cameraView?: \"live\" | \"auto\";\n\n  @property() public aspectRatio?: string;\n\n  @property() public filter?: string;\n\n  @property() public stateFilter?: StateSpecificConfig;\n\n  @property() private _loadError?: boolean;\n\n  @property() private _cameraImageSrc?: string;\n\n  @query(\"img\") private _image!: HTMLImageElement;\n\n  private _lastImageHeight?: number;\n\n  private _cameraUpdater?: number;\n\n  private _attached?: boolean;\n\n  public connectedCallback(): void {\n    super.connectedCallback();\n    this._attached = true;\n    if (this.cameraImage && this.cameraView !== \"live\") {\n      this._startUpdateCameraInterval();\n    }\n  }\n\n  public disconnectedCallback(): void {\n    super.disconnectedCallback();\n    this._attached = false;\n    this._stopUpdateCameraInterval();\n  }\n\n  protected render(): TemplateResult {\n    const ratio = this.aspectRatio ? parseAspectRatio(this.aspectRatio) : null;\n    const stateObj =\n      this.hass && this.entity ? this.hass.states[this.entity] : undefined;\n    const state = stateObj ? stateObj.state : \"unavailable\";\n\n    // Figure out image source to use\n    let imageSrc: string | undefined;\n    let cameraObj: CameraEntity | undefined;\n    // Track if we are we using a fallback image, used for filter.\n    let imageFallback = !this.stateImage;\n\n    if (this.cameraImage) {\n      if (this.cameraView === \"live\") {\n        cameraObj =\n          this.hass && (this.hass.states[this.cameraImage] as CameraEntity);\n      } else {\n        imageSrc = this._cameraImageSrc;\n      }\n    } else if (this.stateImage) {\n      const stateImage = this.stateImage[state];\n\n      if (stateImage) {\n        imageSrc = stateImage;\n      } else {\n        imageSrc = this.image;\n        imageFallback = true;\n      }\n    } else {\n      imageSrc = this.image;\n    }\n\n    if (imageSrc) {\n      imageSrc = this.hass!.hassUrl(imageSrc);\n    }\n\n    // Figure out filter to use\n    let filter = this.filter || \"\";\n\n    if (this.stateFilter && this.stateFilter[state]) {\n      filter = this.stateFilter[state];\n    }\n\n    if (!filter && this.entity) {\n      const isOff = !stateObj || STATES_OFF.includes(state);\n      filter = isOff && imageFallback ? DEFAULT_FILTER : \"\";\n    }\n\n    return html`\n      <div\n        style=${styleMap({\n          paddingBottom:\n            ratio && ratio.w > 0 && ratio.h > 0\n              ? `${((100 * ratio.h) / ratio.w).toFixed(2)}%`\n              : \"\",\n        })}\n        class=${classMap({\n          ratio: Boolean(ratio && ratio.w > 0 && ratio.h > 0),\n        })}\n      >\n        ${this.cameraImage && this.cameraView === \"live\"\n          ? html`\n              <ha-camera-stream\n                .hass=${this.hass}\n                .stateObj=\"${cameraObj}\"\n              ></ha-camera-stream>\n            `\n          : html`\n              <img\n                id=\"image\"\n                src=${imageSrc}\n                @error=${this._onImageError}\n                @load=${this._onImageLoad}\n                style=${styleMap({\n                  filter,\n                  display: this._loadError ? \"none\" : \"block\",\n                })}\n              />\n            `}\n        <div\n          id=\"brokenImage\"\n          style=${styleMap({\n            height: `${this._lastImageHeight || \"100\"}px`,\n            display: this._loadError ? \"block\" : \"none\",\n          })}\n        ></div>\n      </div>\n    `;\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    if (changedProps.has(\"cameraImage\") && this.cameraView !== \"live\") {\n      this._updateCameraImageSrc();\n      this._startUpdateCameraInterval();\n      return;\n    }\n  }\n\n  private _startUpdateCameraInterval(): void {\n    this._stopUpdateCameraInterval();\n    if (this.cameraImage && this._attached) {\n      this._cameraUpdater = window.setInterval(\n        () => this._updateCameraImageSrc(),\n        UPDATE_INTERVAL\n      );\n    }\n  }\n\n  private _stopUpdateCameraInterval(): void {\n    if (this._cameraUpdater) {\n      clearInterval(this._cameraUpdater);\n    }\n  }\n\n  private _onImageError(): void {\n    this._loadError = true;\n  }\n\n  private async _onImageLoad(): Promise<void> {\n    this._loadError = false;\n    await this.updateComplete;\n    this._lastImageHeight = this._image.offsetHeight;\n  }\n\n  private async _updateCameraImageSrc(): Promise<void> {\n    if (!this.hass || !this.cameraImage) {\n      return;\n    }\n\n    const cameraState = this.hass.states[this.cameraImage] as\n      | CameraEntity\n      | undefined;\n\n    if (!cameraState) {\n      this._onImageError();\n      return;\n    }\n\n    this._cameraImageSrc = await fetchThumbnailUrlWithCache(\n      this.hass,\n      this.cameraImage\n    );\n  }\n\n  static get styles(): CSSResult {\n    return css`\n      img {\n        display: block;\n        height: auto;\n        transition: filter 0.2s linear;\n        width: 100%;\n      }\n\n      .ratio {\n        position: relative;\n        width: 100%;\n        height: 0;\n      }\n\n      .ratio img,\n      .ratio div {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n      }\n\n      #brokenImage {\n        background: grey url(\"/static/images/image-broken.svg\") center/36px\n          no-repeat;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-image\": HuiImage;\n  }\n}\n","// Handle 16x9, 16:9, 1.78x1, 1.78:1, 1.78\n// Ignore everything else\nconst parseOrThrow = (num) => {\n  const parsed = parseFloat(num);\n  if (isNaN(parsed)) {\n    throw new Error(`${num} is not a number`);\n  }\n  return parsed;\n};\n\nexport default function parseAspectRatio(input: string) {\n  if (!input) {\n    return null;\n  }\n  try {\n    if (input.endsWith(\"%\")) {\n      return { w: 100, h: parseOrThrow(input.substr(0, input.length - 1)) };\n    }\n\n    const arr = input.replace(\":\", \"x\").split(\"x\");\n    if (arr.length === 0) {\n      return null;\n    }\n\n    return arr.length === 1\n      ? { w: parseOrThrow(arr[0]), h: 1 }\n      : { w: parseOrThrow(arr[0]), h: parseOrThrow(arr[1]) };\n  } catch (err) {\n    // Ignore the error\n  }\n  return null;\n}\n","import { HomeAssistant } from \"../types\";\n\nexport interface AuthProvider {\n  name: string;\n  id: string;\n  type: string;\n}\n\nexport interface Credential {\n  type: string;\n}\n\nexport interface SignedPath {\n  path: string;\n}\n\nexport const hassUrl = `${location.protocol}//${location.host}`;\n\nexport const getSignedPath = (\n  hass: HomeAssistant,\n  path: string\n): Promise<SignedPath> => hass.callWS({ type: \"auth/sign_path\", path });\n\nexport const fetchAuthProviders = () =>\n  fetch(\"/auth/providers\", {\n    credentials: \"same-origin\",\n  });\n"],"sourceRoot":""}